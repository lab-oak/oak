# libpkmn/

The `libpkmn` C API is too barebones for anything beyond the example. It is basically incumbent on the user to replicate some of the zig interface themselves.

## libpkmn/data/

* data/boosts.h
* data/moves.h
* data/species.h
* data/types.h
* data/status.h

Recreating basic `libpkmn` types. In the names of the sleep status conditions, the number at the end represents the stored de-factor duration, e.g. `Sleep1` will wake up upon trying to use a move.

* strings.h

Here we hardcode species/move/type names as char arrays. This is so that we can make the data constexpr, as many compilers still do not support constexpr std::string.

* data.h

The composite data types of `libpkmn` such as `Battle`, `Side`, `Pokemon`, `ActivePokemon` are defined here.  This way members can be accessed directly; `pokemon.level` is much more clear and convenient than `battle.bytes[24 * i + 21]`.

In the remaining code, these structs are only used as references, not constructed as is. We use the overloaded `View::ref(auto&)` function which gives us a 'view' into the underlying byte buffer.

* layout.h

Duplication of the information in `libpkmn`'s layout.json. No magic constants!

* init.h

Helpers for initializing `Battle` and `Durations` structs. A battle is typically initialized from the start of the game using just the team information. In this case intializing is just computing the stats from base stats, setting pp, seeting the seed, and zero'ing certain fields.

This file also handles the extended of functionality of initializing an in progress battle. This means setting bits in the volatiles and durations structs. As always, the battle state is not omniscient so e.g. `duration.confusion` is set rather than `volatiles.confusionLeft`. That is done as needed with the `apply_durations` function.

*  rng.h

Pokemon-Showdown rng. Very fast but low quality - especially if not seeded correctly.

* strings.h

String/print functions for composite types, similar to `libpkmn/data/strings.h`. In particualar `battle_data_to_string` is the only way for a human to see what's going on in a battle.

# data/ 

Format specific data

* teams.h

This is simply all the Smogon RBY OU sample teams, as well as some 'legacy' for benchmark consistency. It is recommended that users replace or augement the data in this file with larger colections of teams. There is a utility `dev/convert.py` for converting Pokemon Showdowns "packed" format into this header but that should not be necessary now that `util/parse` can dynamically load teams from disk.

* legal-moves.h

This hardcoded data tells us whether a pokemon can learn any given move by level 100. RBY does in fact have a few illegal combinations of moves, but not nearly as later generations with egg/event moves. We simply ignore the previous fact, meaning illegal sets like Stun Spore + Stomp Executor are possible in the team generation code. The player consensus is that the banned movesets are not competitively relevant.

* move-pools.h

 Using the previous data, this is a more user-friendly `move_pool(species)` function that returns an a `Move::None` padded array of that pokemons legal moves.

#  search/

* durations.h

The bandit algorithms are implemented in the typical 'single-player' fashion and the combined with the `Joint<>` helper.

## search/bandits

* bandits/ucb.h
* bandits/ucb-policy.h

A single modification to the `c` weight of the UCB algorithm so that it is equivalent to `PUCB` with uniform policy. This is soley to better test the efficacy of policy network inference rather than optimizing playing strength. 

* bandits/exp3.h
* bandits/exp3-policy.h

The `PExp3` algorithm is ad hoc and should be tested and improved.

* joint.h

This pattern does not allow for implementation of 'matrix aware' algorithms like [MatrixUCB](). In practice the cost of computing nash equilibrium at each node was catastrophic for performance in time trials

* mcts.h

Lots to expliain TODO

* tree.h

A node is the joint bandit stats plus a std::map to child nodes. Child nodes are uniquely identified by the tuple of P1 actions, P2 actions, and `pkmn_gen1_chance_actions`. The chance actions are observations of how the turn played out: damage rolls, secondary procs, crits, etc.

This is the reason for the `--option=key` flag in the `Libpkmn` build script. Without this flag, the chance actions would reveal hidden info like sleep rolls.

#  train/

Data structs for training battle and team building models. `BattleFrames` is for battling and stores

* frame.h

A frame is a battle position with value and policy targets. BattleFrames are currently generated by playing out battles but in general a collection of frames is uncorrelated. A frame stores some redundant information (such as result/choices).

There are 3 value targets: the score of the battle, 

# encode/

Oak specific battle and team-gen network encodings

# nn/

NN implementation. Full precision and quantized