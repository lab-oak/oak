#include <data/teams.h>
#include <encode/team.h>
#include <libpkmn/data.h>
#include <libpkmn/strings.h>
#include <nn/network.h>
#include <search/exp3.h>
#include <search/mcts.h>
#include <search/ucb.h>
#include <train/build-trajectory.h>
#include <train/compressed-frame.h>
#include <train/frame.h>
#include <util/random.h>

#include <atomic>
#include <cmath>
#include <csignal>
#include <cstring>
#include <exception>
#include <filesystem>
#include <format>
#include <fstream>
#include <iostream>
#include <sstream>
#include <thread>

#include <fcntl.h>
#include <stdio.h>
#include <unistd.h>

#ifdef NDEBUG
constexpr bool debug = false;
#else
constexpr bool debug = true;
#endif

std::string container_string(const auto &v) {
  std::stringstream ss{};
  for (auto x : v) {
    if constexpr (std::is_same_v<decltype(x), std::string>) {
      ss << x << ' ';
    } else {
      ss << std::to_string(x) << ' ';
    }
  }
  return ss.str();
}

// TODO move to nn
namespace NN {

constexpr auto build_net_hidden_dim = 512;

using BuildNet = EmbeddingNet<Encode::Team::in_dim, build_net_hidden_dim,
                              Encode::Team::out_dim, true, false>;
}; // namespace NN

// Stats for sample team matchup matrix
struct TeamPool {

  static constexpr auto n_teams = Teams::teams.size();
  static constexpr auto n_entries = n_teams * (n_teams - 1) / 2;

  struct Entry {
    std::atomic<size_t> n;
    std::atomic<size_t> v;
  };

  std::array<Entry, n_entries> entries{};

  static constexpr size_t flat(auto i, auto j) {
    if (i < j) {
      return flat(j, i);
    }
    const auto index = i * (i - 1) / 2 + j;
    assert(index < n_entries);
    return index;
  }

  Entry &operator()(auto i, auto j) { return entries[flat(i, j)]; }

  void update(auto i, auto j, auto score) {
    if (i == j) {
      return;
    } else if (i < j) {
      return update(j, i, 2 - score);
    }
    auto &entry = (*this)(i, j);
    entry.n.fetch_add(1);
    entry.v.fetch_add(score);
  }
};

namespace RuntimeOptions {

uint64_t seed = std::random_device{}();
size_t threads = 0;
size_t max_frames = 1 << 30; // actually terminates the program

size_t buffer_size_mb = 8;
size_t max_build_traj = 1 << 10;

size_t print_interval_sec = 30;
bool debug_print = true;

namespace Search {

// iterations/time per search
size_t count = 1 << 10;
// 0 means normal count. First turn eval is also used for team gen
size_t t1_count = 0;
char count_mode = 'i'; // (n)/(i)terations, (t)ime

// search algo, model type/path
char bandit_mode = 'e'; // (e)xp3, (u)cb
std::string battle_network_path;

// move selection
char policy_mode = 'n'; // (n)ash, (e)mpirical, (m)ix
double policy_temp = 1.0;
double policy_min_prob = 0.0; // zerod if below this threshold
double mix_nash_weight = 1.0; // (m)ix mode only

bool keep_node = true; // reuse the search tree after update
}; // namespace Search

namespace TeamGen {
// required since an untrained random network can still act as the source of
// randomness while also generating training data
std::string build_network_path = "";
double modify_team_prob = 0;
double pokemon_delete_prob = 0;
double move_delete_prob = 0;
}; // namespace TeamGen

}; // namespace RuntimeOptions

void print(const auto &data, const bool newline = true) {
  if constexpr (!debug) {
    return;
  }
  if (!RuntimeOptions::debug_print) {
    return;
  }
  std::cout << data;
  if (newline) {
    std::cout << '\n';
  }
}

std::string generate_help_text() {
  std::ostringstream ss;

  ss << "This program generates two kinds of training data using self-play:\n";
  ss << "  battling - The emprical/nash search values/policies.\n";
  ss << "  team building - the trajectories after rolling out an incomplete "
        "team with the build network\n";
  ss << "The agent used in self-play is either monte-carlo rollouts or neural "
        "network eval.\n";
  ss << "Teams are generated by sampling from the pool in "
        "`include/data/teams.h' and then randomly ommiting "
        "information.\n";
  ss << "The missing data is filled in by the build network which produces "
        "training data. If no path is provided then a randomly initialized net "
        "is used.\n";
  ss << "Both team building/battling training data use the final outcome of "
        "the game and the search values (turn 1 only for the build training "
        "data.)\n";
  ss << "Small buffers of battle and training data are continously written to "
        "a run directory which is created in cwd.\n";
  ss << "This continues until enough battle training data has been generated, "
        "or when the program is terminated with SIGINT (ctrl + c).\n";
  ss << "This process is happening indepently in multiple threads. The program "
        "can be paused/resumed with SIGTSTP (ctrl + z)\n";
  ss << "The program also maintains a 'matchup matrix' for all the sample "
        "teams that is updated whenever unmodified teams battle.\n";

  ss << "--karg={DEFAULT}\n";
  ss << "--threads=" << RuntimeOptions::threads << '\n'
     << "  Number of threads to use for parallel computation.\n\n";
  ss << "--seed=" << RuntimeOptions::seed << '\n';
  ss << "  The entire program is deterministic besides filenames. If not "
        "provided, a random seed will be generated.\n\n";
  ss << "--max-frames=" << RuntimeOptions::max_frames << '\n';
  ss << "  Maximum number of total frames to be generated by the program.\n\n";
  ss << "--buffer-size=" << RuntimeOptions::buffer_size_mb << '\n'
     << "  Size of the output buffer in megabytes. \n\n";
  ss << "--print-interval=" << RuntimeOptions::print_interval_sec << '\n'
     << "  Seconds between status prints.\n\n";
  ss << "--count=" << RuntimeOptions::Search::count << '\n'
     << "  Number of iterations/ms to search per battle update.\n\n";
  ss << "--t1-count=" << RuntimeOptions::Search::t1_count << '\n'
     << "  Turn 1 search provides value targets for team gen. A value of 0 "
        "means use the normal count.\n\n";
  ss << "--count-mode=" << RuntimeOptions::Search::count_mode << '\n'
     << "  i : iteration count\n"
     << "  t : milliseconds\n\n";
  ss << "--bandit-mode=" << RuntimeOptions::Search::bandit_mode << '\n'
     << "  e : EXP3\n"
     << "  u : UCB\n\n";
  ss << "--battle-network-path=" << RuntimeOptions::Search::battle_network_path
     << '\n'
     << "  Path to the battle evaluation network.\n"
     << "  If not provided then monte-carlo rollouts will be used for eval "
        "instead.\n\n";
  ss << "--policy-mode=" << RuntimeOptions::Search::policy_mode << '\n'
     << "  Which search policy to use for processing and sampling.\n"
     << "  n : Nash equilibrium of empirical value matrix at the root\n"
     << "  e : Empirical policy\n"
     << "  m : Weighted combination of Nash and empirical\n\n";
  ss << "--policy-temp=" << RuntimeOptions::Search::policy_temp << '\n'
     << "  The 'p' to use for p-normalizing the policy.\n\n";
  ss << "--policy-min-prob=" << RuntimeOptions::Search::policy_min_prob << '\n'
     << "  Minimum probability threshold for policy distribution.\n\n";
  ss << "--mix-nash-weight=" << RuntimeOptions::Search::mix_nash_weight << '\n'
     << "  Weight of the Nash equilibrium for mixed policy mode.\n\n";
  ss << "--keep-node=" << (RuntimeOptions::Search::keep_node ? "true" : "false")
     << '\n'
     << "  If true then the child node corresponding to the battle after an "
        "update will be used for the next search. If there is no such node a "
        "new one is used. If false a new node is always used.\n\n";
  ss << "--build-network-path=\'\'\n"
     << "  Path to the team-building evaluation network. \n\n";
  ss << "--modify-team-prob=" << RuntimeOptions::TeamGen::modify_team_prob
     << '\n'
     << "  Probability of starting the team modification process. Each of the "
        "6 sets are rolled for a delete. If not, then the species is kept and "
        "each of the moves is rolled for a delete. If a team is reduced by "
        "this processes then the build network will finish the team and a "
        "trajectory will be saved.\n\n";
  ss << "--pokemon-delete-prob=" << RuntimeOptions::TeamGen::pokemon_delete_prob
     << '\n'
     << "  Probability of deleting the entire set.\n\n";
  ss << "--move-delete-prob=" << RuntimeOptions::TeamGen::move_delete_prob
     << '\n'
     << "  Probability of deleting any given move.\n\n";
  ss << "--debug-print=" << (RuntimeOptions::debug_print ? "true" : "false")
     << '\n';
  ss << "  Whether to print turn by turn info. Only affects the program when "
        "build in debug mode.\n\n";
  ss << "--help\n"
     << "  Show this help message.\n";

  return ss.str();
}

bool parse_options(int argc, char **argv) {
  if (argc == 1) {
    std::cout << "Usage: ./generate [OPTIONS]\nArg '--threads=' is "
                 "required.\n--help for more."
              << std::endl;
    return true;
  }

  using namespace RuntimeOptions;
  for (int i = 1; i < argc; ++i) {
    std::string arg = argv[i];
    if (arg.starts_with("--help")) {
      std::cout << generate_help_text() << std::endl;
      return true;
    } else if (arg.starts_with("--threads=")) {
      threads = std::stoul(arg.substr(10));
    } else if (arg.starts_with("--seed=")) {
      seed = std::stoul(arg.substr(7));
    } else if (arg.starts_with("--max-frames=")) {
      max_frames = std::stoul(arg.substr(13));
    } else if (arg.starts_with("--buffer-size=")) {
      buffer_size_mb = std::stoul(arg.substr(14));
    } else if (arg.starts_with("--debug-print=")) {
      debug_print = (arg.substr(14)[0] == '1' || arg.substr(14) == "true");
    } else if (arg.starts_with("--print-interval=")) {
      print_interval_sec = std::stoll(arg.substr(17));
    } else if (arg.starts_with("--count=")) {
      Search::count = std::stoul(arg.substr(8));
    } else if (arg.starts_with("--t1-count=")) {
      Search::t1_count = std::stoul(arg.substr(11));
    } else if (arg.starts_with("--count-mode=")) {
      Search::count_mode = arg[13];
    } else if (arg.starts_with("--bandit-mode=")) {
      Search::bandit_mode = arg[14];
    } else if (arg.starts_with("--battle-network-path=")) {
      Search::battle_network_path = arg.substr(22);
    } else if (arg.starts_with("--policy-mode=")) {
      Search::policy_mode = arg[14];
    } else if (arg.starts_with("--policy-temp=")) {
      Search::policy_temp = std::stod(arg.substr(14));
    } else if (arg.starts_with("--policy-min-prob=")) {
      Search::policy_min_prob = std::stod(arg.substr(18));
    } else if (arg.starts_with("--mix-nash-weight=")) {
      Search::mix_nash_weight = std::stod(arg.substr(18));
    } else if (arg.starts_with("--keep-node=")) {
      Search::keep_node =
          (arg.substr(12)[0] == '1' || arg.substr(12) == "true");
    } else if (arg.starts_with("--build-network-path=")) {
      TeamGen::build_network_path = arg.substr(21);
    } else if (arg.starts_with("--modify-team-prob=")) {
      TeamGen::modify_team_prob = std::stod(arg.substr(19));
    } else if (arg.starts_with("--pokemon-delete-prob=")) {
      TeamGen::pokemon_delete_prob = std::stod(arg.substr(22));
    } else if (arg.starts_with("--move-delete-prob=")) {
      TeamGen::move_delete_prob = std::stod(arg.substr(19));
    } else {
      throw std::runtime_error("Invalid arg: " + arg);
    }
  }

  if (Search::t1_count == 0) {
    Search::t1_count = Search::count;
  }

  return threads == 0;
}

std::string runtime_arg_string() {
  using namespace RuntimeOptions;
  std::ostringstream out;
  out << "--threads=" << threads << '\n';
  out << "--seed=" << seed << '\n';
  out << "--max-frames=" << max_frames << '\n';
  out << "--buffer-size=" << buffer_size_mb << '\n';
  out << "--debug-print=" << (debug_print ? "true" : "false") << '\n';
  out << "--print-interval=" << print_interval_sec << '\n';
  out << "--count=" << Search::count << '\n';
  out << "--t1-count=" << Search::t1_count << '\n';
  out << "--count-mode=" << Search::count_mode << '\n';
  out << "--bandit-mode=" << Search::bandit_mode << '\n';
  out << "--battle-network-path=" << Search::battle_network_path << '\n';
  out << "--policy-mode=" << Search::policy_mode << '\n';
  out << "--policy-temp=" << Search::policy_temp << '\n';
  out << "--policy-min-prob=" << Search::policy_min_prob << '\n';
  out << "--mix-nash-weight=" << Search::mix_nash_weight << '\n';
  out << "--keep-node=" << (Search::keep_node ? "true" : "false") << '\n';
  out << "--build-network-path=" << TeamGen::build_network_path << '\n';
  out << "--modify-team-prob=" << TeamGen::modify_team_prob << '\n';
  out << "--pokemon-delete-prob=" << TeamGen::pokemon_delete_prob << '\n';
  out << "--move-delete-prob=" << TeamGen::move_delete_prob << '\n';
  return out.str();
}

namespace RuntimeData {
bool terminated = false;
bool suspended = false;
std::string start_datetime = std::format(
    "{:%F-%T}",
    std::chrono::floor<std::chrono::seconds>(std::chrono::system_clock::now()));
std::atomic<size_t> battle_buffer_counter{};
std::atomic<size_t> build_buffer_counter{};
std::atomic<size_t> frame_counter{};
std::atomic<size_t> traj_counter{};
std::atomic<size_t> update_counter{};
std::atomic<size_t> update_with_node_counter{};
NN::BuildNet build_network{}; // is not battle specific unlike the net
TeamPool team_pool{};
}; // namespace RuntimeData

using Obs = std::array<uint8_t, 16>;
using Exp3Node = Tree::Node<Exp3::JointBandit, Obs>;
using UCBNode = Tree::Node<UCB::JointBandit, Obs>;

// Data that should persist only over a game - not the program or thread
// lifetime. The build network uses a game-specific cache. It is not universal
// unlike the build network.
struct SearchData {
  NN::Network battle_network;
  Exp3::Bandit::Params exp3_params{.03};
  UCB::Bandit::Params ucb_params{.03};
  std::unique_ptr<Exp3Node> exp3_unique_node;
  std::unique_ptr<UCBNode> ucb_unique_node;
};

Train::BuildTrajectory
rollout_build_network(PKMN::Team &team, NN::BuildNet &build_net, auto &device) {
  using namespace Encode::Team;
  Train::BuildTrajectory traj{};

  auto i = 0;
  for (const auto &set : team) {
    if (set.species != Data::Species::None) {
      traj.frames[i++] =
          Train::ActionPolicy{species_move_table(set.species, 0), 0};
      for (const auto move : set.moves) {
        if (move != Data::Move::None) {
          traj.frames[i++] =
              Train::ActionPolicy{species_move_table(set.species, move), 0};
        }
      }
    }
  }

  std::array<float, in_dim> input{};
  write(team, input.data());
  std::array<float, out_dim> mask;
  std::array<float, out_dim> output;

  while (true) {
    mask = {};

    const bool only_requires_lead_selection =
        write_policy_mask(team, mask.data());

    build_net.propagate(input.data(), output.data());

    // softmax
    float sum = 0;
    for (auto k = 0; k < out_dim; ++k) {
      if (mask[k]) {
        output[k] = std::exp(output[k]);
        sum += output[k];
      } else {
        output[k] = 0;
      }
    }
    for (auto &x : output) {
      x /= sum;
    }

    const auto index = device.sample_pdf(output);
    traj.frames[i++] =
        Train::ActionPolicy{static_cast<uint16_t>(index), output[index]};
    input[index] = 1;
    const auto [s, m] = species_move_list(index);
    apply_index_to_team(team, s, m);

    if (only_requires_lead_selection) {
      break;
    }
  }

  return traj;
}

// produces a (modified) team from the pool and the index of unmodified team or
// -1 if modified.
std::tuple<PKMN::Team, int, Train::BuildTrajectory> get_team(mt19937 &device) {
  using namespace RuntimeOptions::TeamGen;

  const auto index = device.random_int(Teams::teams.size());
  auto team = Teams::teams[index];

  // randomly delete mons/moves for the net to fill in
  const auto r = device.uniform();
  if (r < modify_team_prob) {
    for (auto p = 0; p < 6; ++p) {
      const auto r = device.uniform();
      if (r < pokemon_delete_prob) {
        team[p] = {};
      } else {
        for (auto m = 0; m < 4; ++m) {
          const auto rm = device.uniform();
          if (rm < move_delete_prob) {
            team[p].moves[m] = Data::Move::None;
          }
        }
      }
    }
  }

  const bool changed = (team != Teams::teams[index]);
  Train::BuildTrajectory build_traj{};
  if (changed) {
    const auto team_string = [](const auto &team) {
      std::stringstream ss{};
      for (const auto &set : team) {
        ss << species_string(set.species) << ": ";
        for (const auto moveid : set.moves) {
          ss << move_string(moveid) << ' ';
        }
        ss << '\n';
      }
      return ss.str();
    };
    print("Team " + std::to_string(index) + " modified:");
    print(team_string(team));
    build_traj =
        rollout_build_network(team, RuntimeData::build_network, device);
    print(team_string(team));
  }

  return {team, changed ? -1 : index, build_traj};
}

// run search, use output to update battle data and nodes and training frame
auto search(size_t c, mt19937 &device, const BattleData &battle_data,
            SearchData &search_data) {
  using namespace RuntimeOptions::Search;

  auto run_search_model = [&](const auto &bandit_params, auto &unique_node,
                              auto &model) {
    auto &node = *unique_node;
    MCTS search;
    if (count_mode == 'i' || count_mode == 'n') {
      return search.run(c, bandit_params, node, battle_data, model);
    } else if (count_mode == 't') {
      std::chrono::milliseconds ms{c};
      return search.run(ms, bandit_params, node, battle_data, model);
    }
    throw std::runtime_error("Invalid count mode char.");
  };

  auto run_search_node = [&](const auto &bandit_params, auto &unique_node) {
    if (battle_network_path.empty()) {
      MonteCarlo::Model model{device};
      return run_search_model(bandit_params, unique_node, model);
    } else {
      return run_search_model(bandit_params, unique_node,
                              search_data.battle_network);
    }
  };

  if (bandit_mode == 'e') {
    return run_search_node(search_data.exp3_params,
                           search_data.exp3_unique_node);
  } else if (bandit_mode == 'u') {
    return run_search_node(search_data.ucb_params, search_data.ucb_unique_node);
  }
  throw std::runtime_error("Invalid bandit mode char.");
}

std::pair<int, int> sample(mt19937 &device, auto &output) {
  using namespace RuntimeOptions::Search;
  const double t = policy_temp;

  const auto process_and_sample = [&](const auto &policy) {
    if (t <= 0) {
      throw std::runtime_error("Use positive policy power");
    }
    std::vector<double> p(policy.begin(), policy.end());
    double sum = 0;
    for (auto &val : p) {
      val = std::pow(val, t);
      sum += val;
    }
    if (policy_min_prob > 0) {
      const double l = policy_min_prob * sum;
      sum = 0;
      for (auto &val : p) {
        if (val < l)
          val = 0;
        sum += val;
      }
    }
    for (auto &val : p) {
      val /= sum;
    }

    print("Processed policy:");
    print(container_string(p));

    const auto index = device.sample_pdf(p);
    return index;
  };

  if (policy_mode == 'n') {
    return {process_and_sample(output.p1_nash),
            process_and_sample(output.p2_nash)};
  } else if (policy_mode == 'e') {
    return {process_and_sample(output.p1_empirical),
            process_and_sample(output.p2_empirical)};
  } else if (policy_mode == 'm') {
    const auto weighted_sum = [](const auto &a, const auto &b,
                                 const auto alpha) {
      auto result = a;
      std::transform(a.begin(), a.end(), b.begin(), result.begin(),
                     [alpha](const auto &x, const auto &y) {
                       return alpha * x + (decltype(alpha))(1) - alpha * y;
                     });
      return result;
    };
    return {process_and_sample(weighted_sum(output.p1_nash, output.p1_empirical,
                                            mix_nash_weight)),
            process_and_sample(weighted_sum(output.p2_nash, output.p2_empirical,
                                            mix_nash_weight))};
  }
  throw std::runtime_error("Invalid policy mode.");
}

// either reset the node or swap it with its child
void update_nodes(SearchData &search_data, auto i1, auto i2, const auto &obs) {
  auto update_node = [&](auto &unique_node) {
    if (!unique_node || !unique_node->is_init()) {
      return;
    }
    if (RuntimeOptions::Search::keep_node) {
      auto child = unique_node->find(i1, i2, obs);
      RuntimeData::update_counter.fetch_add(1);
      if (child == unique_node->_map.end()) {
        unique_node = std::make_unique<std::decay_t<decltype(*unique_node)>>();
      } else {
        RuntimeData::update_with_node_counter.fetch_add(1);
        auto unique_child =
            std::make_unique<std::decay_t<decltype(*unique_node)>>(
                std::move((*child).second));
        unique_node.swap(unique_child);
      }
    } else {
      unique_node = std::make_unique<std::decay_t<decltype(*unique_node)>>();
    }
  };

  update_node(search_data.exp3_unique_node);
  update_node(search_data.ucb_unique_node);
}

// loop to generate teams, self-play battle with mcts/net, save training
// data for battle and build net
void generate(uint64_t seed) {
  mt19937 device{seed};
  const size_t training_frames_target_size = RuntimeOptions::buffer_size_mb
                                             << 20;
  const size_t thread_frame_buffer_size = (RuntimeOptions::buffer_size_mb + 1)
                                          << 20;
  auto buffer = new char[thread_frame_buffer_size]{};
  size_t frame_buffer_write_index = 0;
  // These are generated slowly so a vector is fine
  std::vector<Train::BuildTrajectory> build_buffer{};

  const auto save_battle_buffer_to_disk = [&buffer, thread_frame_buffer_size,
                                           &frame_buffer_write_index]() {
    const auto filename =
        std::to_string(RuntimeData::battle_buffer_counter.fetch_add(1)) +
        ".battle";
    const auto full_path =
        std::filesystem::path{RuntimeData::start_datetime} / filename;
    int fd = open(full_path.c_str(), O_WRONLY | O_CREAT | O_TRUNC, 0644);
    if (fd >= 0) {
      const auto write_result = write(fd, buffer, frame_buffer_write_index);
      close(fd);
    } else {
      std::cerr << "Failed to write buffer to " << full_path << std::endl;
    }

    std::memset(buffer, 0, thread_frame_buffer_size);
    frame_buffer_write_index = 0;
  };

  const auto save_build_buffer_to_disk = [&build_buffer]() {
    const auto filename =
        std::to_string(RuntimeData::build_buffer_counter.fetch_add(1)) +
        ".build";
    const auto full_path =
        std::filesystem::path{RuntimeData::start_datetime} / filename;

    const int fd = open(full_path.c_str(), O_WRONLY | O_CREAT | O_TRUNC, 0644);
    if (fd >= 0) {
      const size_t bytes_to_write =
          build_buffer.size() * sizeof(Train::BuildTrajectory);
      const ssize_t written = write(fd, build_buffer.data(), bytes_to_write);
      print("build buffer - bytes to write: " + std::to_string(bytes_to_write));
      print("build buffer - bytes written: " + std::to_string(written));
      close(fd);
      if (written != static_cast<ssize_t>(bytes_to_write)) {
        std::cerr << "Short write when flushing build buffer to " << full_path
                  << " (" << written << '/' << bytes_to_write << " bytes)\n";
      }
    } else {
      std::cerr << "Failed to open " << full_path << " for writing\n";
    }

    build_buffer.clear();
  };

  while (true) {
    auto [p1_team, p1_team_index, p1_build_traj] = get_team(device);
    auto [p2_team, p2_team_index, p2_build_traj] = get_team(device);

    const auto battle = PKMN::battle(p1_team, p2_team, device.uniform_64());
    const auto durations = PKMN::durations(p1_team, p2_team);
    BattleData battle_data{battle, durations};
    pkmn_gen1_battle_options battle_options{};
    battle_data.result = PKMN::update(battle_data.battle, 0, 0, battle_options);

    SearchData search_data{
        NN::Network{}, Exp3::Bandit::Params{.03}, UCB::Bandit::Params{2.0},
        std::make_unique<Exp3Node>(), std::make_unique<UCBNode>()};

    std::ifstream file{RuntimeOptions::Search::battle_network_path};
    if (!file) {
      std::cerr << "failed to open file" << std::endl;
    }
    if (!search_data.battle_network.read_parameters(file)) {
      std::cerr << "no battle load " << std::endl;
      throw std::runtime_error{"Failed to load network"};
    }
    search_data.battle_network.fill_cache(battle);

    Train::CompressedFrames<> training_frames{battle_data.battle};

    size_t updates = 0;
    try {
      // playout game
      while (!pkmn_result_type(battle_data.result)) {

        while (RuntimeData::suspended) {
          sleep(1);
        }

        if (RuntimeData::terminated) {
          save_battle_buffer_to_disk();
          save_build_buffer_to_disk();
          delete[] buffer;
          return;
        }

        print(Strings::battle_data_to_string(battle_data.battle,
                                             battle_data.durations, {}));

        // search and sample actions
        const auto output =
            search(updates == 0 ? RuntimeOptions::Search::t1_count
                                : RuntimeOptions::Search::count,
                   device, battle_data, search_data);
        const auto [p1_index, p2_index] = sample(device, output);

        const auto [p1_choices, p2_choices] =
            PKMN::choices(battle_data.battle, battle_data.result);
        const auto p1_choice = p1_choices[p1_index];
        const auto p2_choice = p2_choices[p2_index];

        print("Value: " + std::to_string(output.empirical_value));

        std::vector<std::string> p1_labels{};
        std::vector<std::string> p2_labels{};

        if constexpr (debug) {
          for (auto i = 0; i < p1_choices.size(); ++i) {
            p1_labels.push_back(Strings::side_choice_string(
                battle_data.battle.bytes, p1_choices[i]));
          }
          for (auto i = 0; i < p2_choices.size(); ++i) {
            p2_labels.push_back(Strings::side_choice_string(
                battle_data.battle.bytes + Layout::Sizes::Side, p2_choices[i]));
          }
        }

        print("P1 choices/empiricial/nash:");
        print(container_string(p1_labels));
        print(container_string(output.p1_empirical));
        print(container_string(output.p1_nash));
        print(Strings::side_choice_string(battle_data.battle.bytes, p1_choice));
        print("P2 choices/empiricial/nash:");
        print(container_string(p2_labels));
        print(container_string(output.p2_empirical));
        print(container_string(output.p2_nash));
        print(Strings::side_choice_string(battle_data.battle.bytes + 184,
                                          p2_choice));

        // update train data
        training_frames.updates.emplace_back(output, p1_choice, p2_choice);

        // update battle, durations, result (state info)
        battle_data.result = PKMN::update(battle_data.battle, p1_choice,
                                          p2_choice, battle_options);
        battle_data.durations =
            *pkmn_gen1_battle_options_chance_durations(&battle_options);

        // set nodes
        const auto &obs = *reinterpret_cast<const Obs *>(
            pkmn_gen1_battle_options_chance_actions(&battle_options));
        update_nodes(search_data, p1_index, p2_index, obs);

        ++updates;

        print("update: " + std::to_string(updates));
      }
    } catch (const std::exception &e) {
      std::cerr << e.what() << std::endl;
      continue;
    }

    // build
    if ((p1_team_index >= 0) && (p2_team_index >= 0)) {
      RuntimeData::team_pool.update(p1_team_index, p2_team_index,
                                    PKMN::score(battle_data.result));
    }
    if (p1_team_index == -1) {
      p1_build_traj.score =
          static_cast<uint16_t>(2 * PKMN::score(battle_data.result));
      p1_build_traj.eval = training_frames.updates.front().empirical_value;
      build_buffer.push_back(p1_build_traj);
      RuntimeData::traj_counter.fetch_add(1);
    }
    if (p2_team_index == -1) {
      p2_build_traj.score =
          static_cast<uint16_t>(2 * (1 - PKMN::score(battle_data.result)));
      p2_build_traj.eval = std::numeric_limits<uint16_t>::max() -
                           training_frames.updates.front().empirical_value;
      build_buffer.push_back(p2_build_traj);
      RuntimeData::traj_counter.fetch_add(1);
    }

    // battle
    training_frames.result = battle_data.result;
    const auto n_bytes_frames = training_frames.n_bytes();
    training_frames.write(buffer + frame_buffer_write_index);
    frame_buffer_write_index += n_bytes_frames;

    // stats
    if (RuntimeData::frame_counter.fetch_add(training_frames.updates.size()) >
        RuntimeOptions::max_frames) {
      RuntimeData::terminated = true;
    }

    if (build_buffer.size() >= RuntimeOptions::max_build_traj) {
      save_build_buffer_to_disk();
    }
    if (frame_buffer_write_index >= training_frames_target_size) {
      save_battle_buffer_to_disk();
    }
  }
}

void print_thread_fn() {
  size_t frames_done = 0;
  size_t traj_done = 0;
  while (true) {
    for (int i = 0; i < RuntimeOptions::print_interval_sec; ++i) {
      if (RuntimeData::terminated) {
        return;
      }
      sleep(1);
    }
    const auto frames_more = RuntimeData::frame_counter.load();
    const auto traj_more = RuntimeData::traj_counter.load();
    std::cout << (frames_more - frames_done) /
                     (float)RuntimeOptions::print_interval_sec
              << " battle frames/sec." << std::endl;
    if (RuntimeOptions::TeamGen::modify_team_prob > 0) {
      std::cout << (traj_more - traj_done) /
                       (float)RuntimeOptions::print_interval_sec
                << " build traj./sec." << std::endl;
    }
    if (RuntimeOptions::Search::keep_node) {
      double keep_node_ratio =
          (double)RuntimeData::update_with_node_counter.load() /
          (double)RuntimeData::update_counter.load();
      std::cout << "keep node ratio: " << keep_node_ratio << std::endl;
    }
    const auto progress =
        (double)frames_more / RuntimeOptions::max_frames * 100;
    std::cout << "progress: " << progress << "%" << std::endl;

    frames_done = frames_more;
    traj_done = traj_more;
  }
}

void handle_suspend(int signal) {
  RuntimeData::suspended = !RuntimeData::suspended;
  std::cout << (RuntimeData::suspended ? "Suspended." : "Resumed.")
            << std::endl;
}

void handle_terminate(int signal) {
  RuntimeData::terminated = true;
  RuntimeData::suspended = false;
  std::cout << "Terminated." << std::endl;
}

void create_working_dir() {
  const std::filesystem::path dir_path = RuntimeData::start_datetime;

  std::error_code ec;
  const bool created = std::filesystem::create_directory(dir_path, ec);
  if (ec) {
    std::cerr << "Error creating directory: " << ec.message() << '\n';
  } else if (created) {
    std::cout << "Created directory " << RuntimeData::start_datetime
              << std::endl;
  } else {
    throw std::runtime_error("Could not create datetime dir.");
  }
}

void prepare() {
  // create working dir
  const std::filesystem::path working_dir = RuntimeData::start_datetime;
  std::error_code ec;
  const bool created = std::filesystem::create_directory(working_dir, ec);
  if (ec) {
    std::cerr << "Error creating directory: " << ec.message() << '\n';
  } else if (created) {
    std::cout << "Created directory " << RuntimeData::start_datetime
              << std::endl;
  } else {
    throw std::runtime_error("Could not create datetime dir.");
  }

  // save args
  {
    const auto args_path = working_dir / "args";
    std::ofstream args_file(args_path);
    if (!args_file) {
      throw std::runtime_error("Failed to open args.txt for writing.");
    }
    args_file << runtime_arg_string();
  }

  // build network save/load
  if (RuntimeOptions::TeamGen::build_network_path == "") {
    print("no build network path provided.");
    std::cout << "Build Network: No path provided, saving to work dir."
              << std::endl;
    const auto new_path = working_dir / "build-network";
    std::ofstream stream{new_path, std::ios::binary};
    mt19937 device{RuntimeOptions::seed};
    RuntimeData::build_network.initialize(device);
    RuntimeData::build_network.write_parameters(stream);
  } else {
    std::ifstream stream{RuntimeOptions::TeamGen::build_network_path,
                         std::ios::binary};
    const bool read_success =
        RuntimeData::build_network.read_parameters(stream);
    std::cout << "Build Network read success: "
              << std::string(read_success ? "true" : "false") << std::endl;
  }
}

void cleanup() {
  std::cout << "Sample Team Matchup Info" << std::endl;
  for (auto i = 0; i < TeamPool::n_teams; ++i) {
    for (auto j = 0; j < i; ++j) {
      std::cout << i << ' ' << j << ": ";
      const auto &entry = RuntimeData::team_pool(i, j);
      if (entry.n) {
        std::cout << entry.v / 2.0 / entry.n << std::endl;
      } else {
        std::cout << "N/A" << std::endl;
      }
    }
  }
}

int main(int argc, char **argv) {
  std::signal(SIGINT, handle_terminate);
  std::signal(SIGTSTP, handle_suspend);

  if (const bool exit_early = parse_options(argc, argv)) {
    return 1;
  }

  prepare();

  mt19937 device{RuntimeOptions::seed};

  std::vector<std::thread> thread_pool;
  for (int t = 0; t < RuntimeOptions::threads; ++t) {
    thread_pool.emplace_back(generate, device.uniform_64());
  }
  std::thread print_thread{print_thread_fn};

  for (auto &th : thread_pool) {
    th.join();
  }
  print_thread.join();

  cleanup();

  return 0;
}
