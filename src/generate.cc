#include <data/teams.h>
#include <nn/build-network.h>
#include <nn/network.h>
#include <train/build-trajectory.h>
#include <train/compressed-frame.h>
#include <train/frame.h>
#include <util/parse.h>
#include <util/policy.h>
#include <util/random.h>
#include <util/search.h>

#include <atomic>
#include <thread>

#ifdef NDEBUG
constexpr bool debug = false;
#else
constexpr bool debug = true;
#endif

namespace RuntimeOptions {

uint64_t seed = std::random_device{}();
size_t threads = 0;
size_t max_frames = 1 << 30;

size_t buffer_size_mb = 8;
size_t max_build_traj = 1 << 10;

size_t print_interval_sec = 30;
bool debug_print = true;

bool keep_node = true;

RuntimeSearch::Agent agent{"4096", "exp3-0.03", "mc"};
RuntimeSearch::Agent t1_agent;
RuntimePolicy::Options policy_options{};

namespace TeamGen {
// required since an untrained random network can still act as the source of
// randomness while also generating training data
uint max_pokemon = 6;
double skip_game_prob = 0;
std::string teams_path = "";
std::string network_path = "";
double modify_team_prob = 0;
double pokemon_delete_prob = 0;
double move_delete_prob = 0;
}; // namespace TeamGen

}; // namespace RuntimeOptions

void print(const auto &data, const bool newline = true) {
  if constexpr (!debug) {
    return;
  }
  if (!RuntimeOptions::debug_print) {
    return;
  }
  std::cout << data;
  if (newline) {
    std::cout << '\n';
  }
}

auto generate_help_text() -> std::string {
  using namespace RuntimeOptions;
  std::ostringstream ss;
  ss << "This program generates two kinds of training data using self-play:\n";
  ss << "  battling - The empirical/nash search values/policies.\n";
  ss << "  team building - the trajectories after rolling out an incomplete "
        "team with the build network\n";
  ss << "The agent used in self-play is either monte-carlo rollouts or neural "
        "network eval.\n";
  ss << "Teams are generated by sampling from the pool in "
        "`include/data/teams.h' and then randomly omitting "
        "information.\n";
  ss << "The missing data is filled in by the build network which produces "
        "training data. If no path is provided then a randomly initialized net "
        "is used.\n";
  ss << "Both team building/battling training data use the final outcome of "
        "the game and the search values (turn 1 only for the build training "
        "data.)\n";
  ss << "Small buffers of battle and training data are continuously written to "
        "a run directory which is created in cwd.\n";
  ss << "This continues until enough battle training data has been generated, "
        "or when the program is terminated with SIGINT (ctrl + c).\n";
  ss << "This process is happening independently in multiple threads. The "
        "program "
        "can be paused/resumed with SIGTSTP (ctrl + z)\n";
  ss << "The program also maintains a 'matchup matrix' for all the sample "
        "teams that is updated whenever two unmodified teams battle.\n\n";
  ss << "--threads=" << threads << '\n'
     << "  Number of threads to use for parallel computation.\n\n";
  ss << "--seed=" << seed << '\n'
     << "  Seed for random number generation. If not provided, a random seed "
        "will be generated.\n\n";
  ss << "--max-frames=" << max_frames << '\n'
     << "  Maximum number of total frames to be generated by the program.\n\n";
  ss << "--buffer-size=" << buffer_size_mb << '\n'
     << "  Size of the output buffer in megabytes.\n\n";
  ss << "--print-interval=" << print_interval_sec << '\n'
     << "  Seconds between status prints.\n\n";
  ss << "--debug-print=" << (debug_print ? "true" : "false") << '\n'
     << "  Whether to print turn-by-turn info (debug builds only).\n\n";
  ss << "--search-time=" << agent.search_time << '\n'
     << "  Search time setting for the primary agent.\n\n";
  ss << "--bandit-name=" << agent.bandit_name << '\n'
     << "  Bandit algorithm name for the primary agent (e.g., exp3, ucb).\n\n";
  ss << "--battle-network-path=" << agent.network_path << '\n'
     << "  Path to the battle evaluation network. If empty, Monte Carlo "
        "rollouts are used.\n\n";
  ss << "--policy-mode=" << policy_options.mode << '\n'
     << "  Which search policy to use for processing and sampling.\n"
     << "  n : Nash equilibrium at the root\n"
     << "  e : Empirical policy\n"
     << "  m : Weighted combination of Nash and empirical\n\n";
  ss << "--policy-temp=" << policy_options.temp << '\n'
     << "  The 'p' value for p-normalizing the policy.\n\n";
  ss << "--policy-min-prob=" << policy_options.min_prob << '\n'
     << "  Minimum probability threshold for policy distribution.\n\n";
  ss << "--policy-nash-weight=" << policy_options.nash_weight << '\n'
     << "  Weight of the Nash equilibrium for mixed policy mode.\n\n";
  ss << "--keep-node=" << (keep_node ? "true" : "false") << '\n'
     << "  If true, reuse the corresponding child node after a search update "
        "if available.\n\n";
  ss << "--skip-game-prob=" << TeamGen::skip_game_prob << '\n'
     << "  Probability of skipping a game entirely when generating teams.\n\n";
  ss << "--max-pokemon=" << TeamGen::max_pokemon << '\n'
     << "  Maximum Pokémon per team.\n\n";
  ss << "--teams=" << TeamGen::teams_path << '\n'
     << "  Path to a directory of team files.\n\n";
  ss << "--build-network-path=" << TeamGen::network_path << '\n'
     << "  Path to the team-building evaluation network.\n\n";
  ss << "--modify-team-prob=" << TeamGen::modify_team_prob << '\n'
     << "  Probability of starting the team modification process.\n\n";
  ss << "--pokemon-delete-prob=" << TeamGen::pokemon_delete_prob << '\n'
     << "  Probability of deleting an entire set during modification.\n\n";
  ss << "--move-delete-prob=" << TeamGen::move_delete_prob << '\n'
     << "  Probability of deleting a move during modification.\n\n";
  ss << "--t1-search-time=" << t1_agent.search_time << '\n'
     << "  Search time setting for the turn-1 agent.\n\n";
  ss << "--t1-bandit-name=" << t1_agent.bandit_name << '\n'
     << "  Bandit algorithm name for the turn-1 agent.\n\n";
  ss << "--t1-battle-network-path=" << t1_agent.network_path << '\n'
     << "  Path to the battle evaluation network for the turn-1 agent.\n\n";
  ss << "--help\n"
     << "  Show this help message.\n";
  return ss.str();
}

bool parse_options(int argc, char **argv) {
  using namespace RuntimeOptions;

  if (argc < 2) {
    std::cout << "Usage: ./generate [OPTIONS]\nArg '--threads=' is "
                 "required.\n--help for more."
              << std::endl;
    return true;
  }

  std::vector<char *> args(argv, argv + argc);
  assert(args.size() == argc);

  for (auto &a : args) {
    if (a == nullptr) {
      continue;
    }
    char *b = nullptr;
    std::swap(a, b);
    std::string arg{a};
    if (arg.starts_with("--help")) {
      std::cout << generate_help_text() << std::endl;
      return true;
    } else if (arg.starts_with("--threads=")) {
      threads = std::stoul(arg.substr(10));
    } else if (arg.starts_with("--seed=")) {
      seed = std::stoul(arg.substr(7));
    } else if (arg.starts_with("--max-frames=")) {
      max_frames = std::stoul(arg.substr(13));
    } else if (arg.starts_with("--buffer-size=")) {
      buffer_size_mb = std::stoul(arg.substr(14));
    } else if (arg.starts_with("--debug-print=")) {
      debug_print = (arg.substr(14)[0] == '1' || arg.substr(14) == "true");
    } else if (arg.starts_with("--print-interval=")) {
      print_interval_sec = std::stoll(arg.substr(17));
    } else if (arg.starts_with("--search-time=")) {
      t1_agent.search_time = arg.substr(14);
    } else if (arg.starts_with("--bandit-name=")) {
      t1_agent.bandit_name = arg.substr(14);
    } else if (arg.starts_with("--battle-network-path=")) {
      t1_agent.network_path = arg.substr(22);
    } else if (arg.starts_with("--policy-mode=")) {
      policy_options.mode = arg[14];
    } else if (arg.starts_with("--policy-temp=")) {
      policy_options.temp = std::stod(arg.substr(14));
    } else if (arg.starts_with("--policy-min-prob=")) {
      policy_options.min_prob = std::stod(arg.substr(18));
    } else if (arg.starts_with("--policy-nash-weight=")) {
      policy_options.nash_weight = std::stod(arg.substr(21));
    } else if (arg.starts_with("--keep-node=")) {
      keep_node = (arg.substr(12)[0] == '1' || arg.substr(12) == "true");
    } else if (arg.starts_with("--skip-game-prob=")) {
      TeamGen::skip_game_prob = std::stoul(arg.substr(17));
    } else if (arg.starts_with("--max-pokemon=")) {
      TeamGen::max_pokemon = std::stoul(arg.substr(14));
    } else if (arg.starts_with("--teams=")) {
      TeamGen::teams_path = arg.substr(8);
    } else if (arg.starts_with("--build-network-path=")) {
      TeamGen::network_path = arg.substr(21);
    } else if (arg.starts_with("--modify-team-prob=")) {
      TeamGen::modify_team_prob = std::stod(arg.substr(19));
    } else if (arg.starts_with("--pokemon-delete-prob=")) {
      TeamGen::pokemon_delete_prob = std::stod(arg.substr(22));
    } else if (arg.starts_with("--move-delete-prob=")) {
      TeamGen::move_delete_prob = std::stod(arg.substr(19));
    } else {
      std::swap(a, b);
    }
  }

  t1_agent = agent;

  for (auto &a : args) {
    if (a == nullptr) {
      continue;
    }
    char *b = nullptr;
    std::swap(a, b);
    std::string arg{a};
    if (arg.starts_with("--t1-search-time=")) {
      t1_agent.search_time = arg.substr(17);
    } else if (arg.starts_with("--t1-bandit-name=")) {
      t1_agent.bandit_name = arg.substr(17);
    } else if (arg.starts_with("--t1-battle-network-path=")) {
      t1_agent.network_path = arg.substr(25);
    } else {
      std::swap(a, b);
    }
  }

  for (auto a : args) {
    if (a != nullptr) {
      throw std::runtime_error{"Unrecognized arg: " + std::string(a)};
    }
  }

  return threads == 0;
}

auto runtime_arg_string() -> std::string {
  using namespace RuntimeOptions;
  std::ostringstream out;
  out << "--threads=" << threads << '\n';
  out << "--seed=" << seed << '\n';
  out << "--max-frames=" << max_frames << '\n';
  out << "--buffer-size=" << buffer_size_mb << '\n';
  out << "--debug-print=" << (debug_print ? "true" : "false") << '\n';
  out << "--print-interval=" << print_interval_sec << '\n';

  out << "--search-time=" << agent.search_time << '\n';
  out << "--bandit-name=" << agent.bandit_name << '\n';
  out << "--battle-network-path=" << agent.network_path << '\n';

  out << "--policy-mode=" << policy_options.mode << '\n';
  out << "--policy-temp=" << policy_options.temp << '\n';
  out << "--policy-min-prob=" << policy_options.min_prob << '\n';
  out << "--policy-nash-weight=" << policy_options.nash_weight << '\n';

  out << "--keep-node=" << (keep_node ? "true" : "false") << '\n';
  out << "--skip-game-prob=" << TeamGen::skip_game_prob << '\n';
  out << "--max-pokemon=" << TeamGen::max_pokemon << '\n';
  out << "--teams=" << TeamGen::teams_path << '\n';
  out << "--build-network-path=" << TeamGen::network_path << '\n';
  out << "--modify-team-prob=" << TeamGen::modify_team_prob << '\n';
  out << "--pokemon-delete-prob=" << TeamGen::pokemon_delete_prob << '\n';
  out << "--move-delete-prob=" << TeamGen::move_delete_prob << '\n';

  out << "--t1-search-time=" << t1_agent.search_time << '\n';
  out << "--t1-bandit-name=" << t1_agent.bandit_name << '\n';
  out << "--t1-battle-network-path=" << t1_agent.network_path << '\n';

  return out.str();
}

// Stats for sample team matchup matrix
struct MatchupMatrix {
  MatchupMatrix() = default;
  MatchupMatrix(const auto size)
      : n_teams{size}, n_entries{n_teams * (n_teams - 1) / 2} {
    entries.resize(n_entries);
  }

  struct Entry {
    std::atomic<size_t> n;
    std::atomic<size_t> v;
  };

  size_t n_teams;
  size_t n_entries;
  std::vector<Entry> entries{};

  size_t flat(auto i, auto j) {
    if (i < j) {
      return flat(j, i);
    }
    const auto index = i * (i - 1) / 2 + j;
    assert(index < n_entries);
    return index;
  }

  Entry &operator()(auto i, auto j) { return entries[flat(i, j)]; }

  void update(auto i, auto j, auto score) {
    if (i == j) {
      return;
    } else if (i < j) {
      return update(j, i, 2 - score);
    }
    auto &entry = (*this)(i, j);
    entry.n.fetch_add(1);
    entry.v.fetch_add(score);
  }
};

namespace RuntimeData {
bool terminated = false;
bool suspended = false;
std::string start_datetime = std::format(
    "{:%F-%T}",
    std::chrono::floor<std::chrono::seconds>(std::chrono::system_clock::now()));
std::atomic<size_t> battle_buffer_counter{};
std::atomic<size_t> build_buffer_counter{};
std::atomic<size_t> frame_counter{};
std::atomic<size_t> traj_counter{};
std::atomic<size_t> update_counter{};
std::atomic<size_t> update_with_node_counter{};
std::vector<PKMN::Team> teams;
MatchupMatrix matchup_matrix;
}; // namespace RuntimeData

auto generate_team(mt19937 &device)
    -> std::tuple<std::vector<PKMN::Set>, int, Train::BuildTrajectory> {
  using namespace RuntimeOptions::TeamGen;

  const auto index = device.random_int(Teams::teams.size());
  const auto base_team = RuntimeData::teams[index];
  std::vector<PKMN::Set> team{base_team.begin(),
                              base_team.begin() + max_pokemon};
  const auto original_team = team;
  // randomly delete mons/moves for the net to fill in
  const auto r = device.uniform();
  if (r < modify_team_prob) {
    for (auto p = 0; p < max_pokemon; ++p) {
      const auto r = device.uniform();
      if (r < pokemon_delete_prob) {
        team[p] = {};
      } else {
        for (auto m = 0; m < 4; ++m) {
          const auto rm = device.uniform();
          if (rm < move_delete_prob) {
            team[p].moves[m] = Data::Move::None;
          }
        }
      }
    }
  }

  if (team == original_team) {
    return {team, index, {}};
  } else {
    const auto team_string = [](const auto &team) {
      std::stringstream ss{};
      for (const auto &set : team) {
        ss << species_string(set.species) << ": ";
        for (const auto moveid : set.moves) {
          ss << move_string(moveid) << ' ';
        }
        ss << '\n';
      }
      return ss.str();
    };
    print("Team " + std::to_string(index) + " modified:");
    print(team_string(team));
    NN::BuildNetwork build_network{};
    std::ifstream file{RuntimeOptions::TeamGen::network_path};
    build_network.read_parameters(file);
    print(team_string(team));
    return {team, -1, NN::rollout_build_network(team, build_network, device)};
  }
}

void generate(uint64_t seed) {
  mt19937 device{seed};
  const size_t training_frames_target_size = RuntimeOptions::buffer_size_mb
                                             << 20;
  const size_t thread_frame_buffer_size = (RuntimeOptions::buffer_size_mb + 1)
                                          << 20;

  auto buffer = new char[thread_frame_buffer_size]{};
  size_t frame_buffer_write_index = 0;
  // These are generated slowly so a vector is fine
  std::vector<Train::BuildTrajectory> build_buffer{};

  const auto save_battle_buffer_to_disk = [&buffer, thread_frame_buffer_size,
                                           &frame_buffer_write_index]() {
    const auto filename =
        std::to_string(RuntimeData::battle_buffer_counter.fetch_add(1)) +
        ".battle";
    const auto full_path =
        std::filesystem::path{RuntimeData::start_datetime} / filename;
    int fd = open(full_path.c_str(), O_WRONLY | O_CREAT | O_TRUNC, 0644);
    if (fd >= 0) {
      const auto write_result = write(fd, buffer, frame_buffer_write_index);
      close(fd);
    } else {
      std::cerr << "Failed to write buffer to " << full_path << std::endl;
    }

    std::memset(buffer, 0, thread_frame_buffer_size);
    frame_buffer_write_index = 0;
  };

  const auto save_build_buffer_to_disk = [&build_buffer]() {
    const auto filename =
        std::to_string(RuntimeData::build_buffer_counter.fetch_add(1)) +
        ".build";
    const auto full_path =
        std::filesystem::path{RuntimeData::start_datetime} / filename;

    const int fd = open(full_path.c_str(), O_WRONLY | O_CREAT | O_TRUNC, 0644);
    if (fd >= 0) {
      const size_t bytes_to_write =
          build_buffer.size() * sizeof(Train::BuildTrajectory);
      const ssize_t written = write(fd, build_buffer.data(), bytes_to_write);
      print("build buffer - bytes to write: " + std::to_string(bytes_to_write));
      print("build buffer - bytes written: " + std::to_string(written));
      close(fd);
      if (written != static_cast<ssize_t>(bytes_to_write)) {
        std::cerr << "Short write when flushing build buffer to " << full_path
                  << " (" << written << '/' << bytes_to_write << " bytes)\n";
      }
    } else {
      std::cerr << "Failed to open " << full_path << " for writing\n";
    }

    build_buffer.clear();
  };

  while (true) {

    auto [p1_team, p1_team_index, p1_build_traj] = generate_team(device);
    auto [p2_team, p2_team_index, p2_build_traj] = generate_team(device);

    auto battle = PKMN::battle(p1_team, p2_team, device.uniform_64());
    const auto durations = PKMN::durations(p1_team, p2_team);
    apply_durations(battle, durations);

    BattleData battle_data{battle, durations, PKMN::result(battle)};
    auto options = PKMN::options();
    battle_data.result = PKMN::result();

    Train::CompressedFrames training_frames{battle_data.battle};

    auto agent = RuntimeOptions::agent;
    auto t1_agent = RuntimeOptions::t1_agent;
    auto nodes = RuntimeOptions::nodes;

    // if the std::optional<NN::Network> is not set then the params/cache will
    // be loaded/filled before every turn.
    if (!agent.is_monte_carlo()) {
      agent.read_network_parameters();
      agent.network.value().fill_cache(battle_data.battle);
    }

    size_t updates = 0;
    try {

      while (!pkmn_result_type(battle_data.result)) {

        while (RuntimeData::suspended) {
          sleep(1);
        }

        if (RuntimeData::terminated) {
          save_battle_buffer_to_disk();
          save_build_buffer_to_disk();
          delete[] buffer;
          return;
        }

        print(Strings::battle_data_to_string(battle_data.battle,
                                             battle_data.durations));

        // search and sample actions
        const auto output =
            search(updates == 0 ? RuntimeOptions::Search::t1_count
                                : RuntimeOptions::Search::count,
                   device, battle_data, search_data);

        if (updates == 0) {
          agent =
        }

        const auto output = RuntimeSearch::run(
            battle_data, nodes, (updates == 0) ? t1_agent : agent);
        const auto p1_index =
            process_and_sample(device, output.p1_empirical, output.p1_nash,
                               RuntimeOptions::policy_options);
        const auto p2_index =
            process_and_sample(device, output.p2_empirical, output.p2_nash,
                               RuntimeOptions::policy_options);
        const auto p1_choice = output.p1_choices[p1_index];
        const auto p2_choice = output.p2_choices[p2_index];

        // update train data
        training_frames.updates.emplace_back(output, p1_choice, p2_choice);

        // update battle, durations, result (state info)
        battle_data.result = PKMN::update(battle_data.battle, p1_choice,
                                          p2_choice, battle_options);
        battle_data.durations =
            *pkmn_gen1_battle_options_chance_durations(&battle_options);

        // set nodes
        const auto &obs = *reinterpret_cast<const MCTS::Obs *>(
            pkmn_gen1_battle_options_chance_actions(&battle_options));
        if (RuntimeOptions::keep_node) {
          nodes.update(search_data, p1_index, p2_index, obs);
        } else {
          nodes.reset();
        }

        ++updates;
        print("update: " + std::to_string(updates));
      }
    } catch (const std::exception &e) {
      std::cerr << e.what() << std::endl;
      continue;
    }

    // build
    if ((p1_team_index >= 0) && (p2_team_index >= 0)) {
      RuntimeData::matchup_matrix.update(p1_team_index, p2_team_index,
                                         PKMN::score(battle_data.result));
    }
    if (p1_team_index == -1) {
      p1_build_traj.score =
          static_cast<uint16_t>(2 * PKMN::score(battle_data.result));
      p1_build_traj.eval = training_frames.updates.front().empirical_value;
      build_buffer.push_back(p1_build_traj);
      RuntimeData::traj_counter.fetch_add(1);
    }
    if (p2_team_index == -1) {
      p2_build_traj.score =
          static_cast<uint16_t>(2 * (1 - PKMN::score(battle_data.result)));
      p2_build_traj.eval = std::numeric_limits<uint16_t>::max() -
                           training_frames.updates.front().empirical_value;
      build_buffer.push_back(p2_build_traj);
      RuntimeData::traj_counter.fetch_add(1);
    }

    // battle
    training_frames.result = battle_data.result;
    const auto n_bytes_frames = training_frames.n_bytes();
    training_frames.write(buffer + frame_buffer_write_index);
    frame_buffer_write_index += n_bytes_frames;

    // data
    if (RuntimeData::frame_counter.fetch_add(training_frames.updates.size()) >
        RuntimeOptions::max_frames) {
      RuntimeData::terminated = true;
    }

    if (build_buffer.size() >= RuntimeOptions::max_build_traj) {
      save_build_buffer_to_disk();
    }
    if (frame_buffer_write_index >= training_frames_target_size) {
      save_battle_buffer_to_disk();
    }
  }
}

void print_thread_fn() {
  size_t frames_done = 0;
  size_t traj_done = 0;
  while (true) {
    for (int i = 0; i < RuntimeOptions::print_interval_sec; ++i) {
      if (RuntimeData::terminated) {
        return;
      }
      sleep(1);
    }
    const auto frames_more = RuntimeData::frame_counter.load();
    const auto traj_more = RuntimeData::traj_counter.load();
    std::cout << (frames_more - frames_done) /
                     (float)RuntimeOptions::print_interval_sec
              << " battle frames/sec." << std::endl;
    if (RuntimeOptions::TeamGen::modify_team_prob > 0) {
      std::cout << (traj_more - traj_done) /
                       (float)RuntimeOptions::print_interval_sec
                << " build traj./sec." << std::endl;
    }
    if (RuntimeOptions::keep_node) {
      double keep_node_ratio =
          (double)RuntimeData::update_with_node_counter.load() /
          (double)RuntimeData::update_counter.load();
      std::cout << "keep node ratio: " << keep_node_ratio << std::endl;
    }
    const auto progress =
        (double)frames_more / RuntimeOptions::max_frames * 100;
    std::cout << "progress: " << progress << "%" << std::endl;

    frames_done = frames_more;
    traj_done = traj_more;
  }
}

void create_working_dir() {
  const std::filesystem::path dir_path = RuntimeData::start_datetime;

  std::error_code ec;
  const bool created = std::filesystem::create_directory(dir_path, ec);
  if (ec) {
    std::cerr << "Error creating directory: " << ec.message() << '\n';
  } else if (created) {
    std::cout << "Created directory " << RuntimeData::start_datetime
              << std::endl;
  } else {
    throw std::runtime_error("Could not create datetime dir.");
  }
}

void setup() {
  // create working dir
  const std::filesystem::path working_dir = RuntimeData::start_datetime;
  std::error_code ec;
  const bool created = std::filesystem::create_directory(working_dir, ec);
  if (ec) {
    std::cerr << "Error creating directory: " << ec.message() << '\n';
    throw std::runtime_error("Could not create datetime dir.");
  } else if (created) {
    std::cout << "Created directory " << RuntimeData::start_datetime
              << std::endl;
  } else {
    throw std::runtime_error("Could not create datetime dir.");
  }

  // save args
  {
    const auto args_path = working_dir / "args";
    std::ofstream args_file(args_path);
    if (!args_file) {
      throw std::runtime_error("Failed to open args.txt for writing.");
    }
    args_file << runtime_arg_string();
  }
  // get teams
  if (!RuntimeOptions::TeamGen::teams_path.empty()) {
    using RuntimeData::teams;
    std::ifstream file{RuntimeOptions::TeamGen::teams_path};
    while (true) {
      std::string line{};
      std::getline(file, line);
      if (line.empty()) {
        break;
      }
      const auto [side, volatiles] = Parse::parse_side(line);
      RuntimeData::teams.push_back(side);
    }
    if (RuntimeData::teams.size() == 0) {
      throw std::runtime_error{"Could not parse teams"};
    }
  } else {
    RuntimeData::teams = {Teams::teams.begin(), Team::teams.end()};
    RuntimeData::matchup_matrix = MatchupMatrix{RuntimeData::teams.size()};
  }

  // build network save/load
  if (RuntimeOptions::TeamGen::network_path == "") {
    print("no build network path provided.");
    std::cout << "Build Network: No path provided, saving to work dir."
              << std::endl;
    const auto new_path = working_dir / "build-network";
    std::ofstream stream{new_path, std::ios::binary};
    mt19937 device{RuntimeOptions::seed};
    RuntimeData::build_network.initialize(device);
    RuntimeData::build_network.write_parameters(stream);
  }
}

void cleanup() {
  std::cout << "Sample Team Matchup Info" << std::endl;
  for (auto i = 0; i < MatchupMatrix::n_teams; ++i) {
    for (auto j = 0; j < i; ++j) {
      std::cout << i << ' ' << j << ": ";
      const auto &entry = RuntimeData::matchup_matrix(i, j);
      if (entry.n) {
        std::cout << entry.v / 2.0 / entry.n << std::endl;
      } else {
        std::cout << "N/A" << std::endl;
      }
    }
  }
}

void handle_suspend(int signal) {
  RuntimeData::suspended = !RuntimeData::suspended;
  std::cout << (RuntimeData::suspended ? "Suspended." : "Resumed.")
            << std::endl;
}

void handle_terminate(int signal) {
  RuntimeData::terminated = true;
  RuntimeData::suspended = false;
  std::cout << "Terminated." << std::endl;
}

int main(int argc, char **argv) {
  std::signal(SIGINT, handle_terminate);
  std::signal(SIGTSTP, handle_suspend);

  if (const bool exit_early = parse_options(argc, argv)) {
    return 1;
  }

  setup();

  mt19937 device{RuntimeOptions::seed};

  std::vector<std::thread> thread_pool;
  for (int t = 0; t < RuntimeOptions::threads; ++t) {
    thread_pool.emplace_back(generate, device.uniform_64());
  }
  std::thread print_thread{print_thread_fn};

  for (auto &th : thread_pool) {
    th.join();
  }
  print_thread.join();

  cleanup();

  return 0;
}
